import React, { useEffect, useMemo, useState } from "react";

/**

Battle Ã  la carte â€“ ãƒ–ãƒ©ã‚¦ã‚¶ç‰ˆï¼ˆv0.9 ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼‰


---

âœ… 2äººå¯¾æˆ¦ï¼ˆã‚ãªãŸ vs CPUï¼‰

âœ… ãƒ«ãƒ¼ãƒ«å®Ÿè£…ï¼š

ãƒ‰ãƒ­ãƒ¼/ãƒ¡ã‚¤ãƒ³/ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ³ãƒ‰å„ãƒ•ã‚§ã‚¤ã‚º


ã‚»ãƒƒãƒˆï¼ˆ2æšã¾ã§ï¼å†·å‡åº«ã§3æšã¾ã§ï¼‰


å½¹ä½œæˆï¼ˆãƒ¬ã‚·ãƒ”ç…§åˆï¼‰


ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆ1ã‚¿ãƒ¼ãƒ³1æšã¾ã§ï¼‰


åŠ å·¥ã‚«ãƒ¼ãƒ‰ã®è³¼å…¥ï¼ˆå„3ç‚¹ï¼‰


å‹åˆ©æ¡ä»¶ï¼ˆ10ç‚¹/ç‰¹æ®Šå‹åˆ©2ç¨®ï¼‰


âœ… CPUç°¡æ˜“AIï¼ˆå½¹ä½œã‚Šâ†’ã‚¤ãƒ™ãƒ³ãƒˆâ†’ã‚»ãƒƒãƒˆâ†’ã‚¨ãƒ³ãƒ‰ï¼‰

âœ… ãƒ­ã‚°ãƒ»å–ã‚Šæ¶ˆã—ä¸å¯ï¼ˆä»Šå¾Œè¿½åŠ äºˆå®šï¼‰

ğŸ§ª ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼š

ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ³ãƒ‰ã®æ‰‹æœ­åˆ¶é™ï¼šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€Œæ‰‹æœ­ãŒ4æšä»¥ä¸Šãªã‚‰2æšã ã‘æ®‹ã™ã€


ï¼ˆè¨­å®šã§ã€Œ3æšä»¥ä¸Šãªã‚‰â€¦ã€ã«ã‚‚åˆ‡æ›¿å¯èƒ½ï¼‰

30%ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ ãƒ‰ãƒ­ãƒ¼ï¼ˆè¨­å®šã§ON/OFFï¼‰â€»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆOFFï¼ˆç¾ãƒ«ãƒ¼ãƒ«æº–æ‹ ï¼‰


ä»Šå¾Œã®æ”¹å–„å€™è£œï¼š

ç‰©ã€…äº¤æ›ã®UIæ”¹å–„ï¼ˆCPUæ‰‹æœ­ã®è¡¨ç¤º/é¸æŠã‚’åˆ†ã‹ã‚Šã‚„ã™ãï¼‰


ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³/åŠ¹æœéŸ³


3ã€œ4äººãƒ—ãƒ¬ã‚¤å¯¾å¿œ */



// -------------- å®šç¾©ãƒ‡ãƒ¼ã‚¿ ---------------- const MATERIAL_COUNTS: Record<string, number> = { "ã”é£¯": 4, "ã®ã‚Š": 4, "ãƒãƒŠãƒŠ": 2, "ã‚«ãƒ¬ãƒ¼ç²‰": 2, "é¶è‚‰": 2, "è±šè‚‰": 2, "ç‰›è‚‰": 2, "é­šè‚‰": 2, "ç‰›ä¹³": 4, "åµ": 2, "ã‚­ãƒ£ãƒ™ãƒ„": 2, "ã«ã‚“ã˜ã‚“": 2, "ã˜ã‚ƒãŒã„ã‚‚": 2, "ç‰ã­ã": 2, "å¤§æ ¹": 2, };

const EVENT_NAMES = [ "ã‚´ãƒŸåé›†è»Š", "ç‰©ã€…äº¤æ›", "ã‚„ã£ã±ã‚„ãƒ¼ã‚ãŸã£ï¼", "ã‚„ã‚Šç›´ã—", "å‰µä½œæ–™ç†", "çˆ†è²·ã„", "é£Ÿææ¢ç´¢", "å¤§æƒé™¤", "ç·Šæ€¥èª¿ç†", ];

// å„ã‚¤ãƒ™ãƒ³ãƒˆã¯2æšãšã¤ const EVENT_COUNTS: Record<string, number> = Object.fromEntries( EVENT_NAMES.map((n) => [n, 2]) );

// åŠ å·¥ã‚«ãƒ¼ãƒ‰ï¼ˆã‚µãƒ—ãƒ©ã‚¤ã«ç½®ã‹ã‚Œã¦è³¼å…¥ã™ã‚‹ï¼‰ const TOOLS = ["åŒ…ä¸", "å†·å‡åº«", "ã¾ãªæ¿"] as const; const TOOL_COUNTS: Record<(typeof TOOLS)[number], number> = { åŒ…ä¸: 2, å†·å‡åº«: 2, ã¾ãªæ¿: 2, };

// ãƒ¬ã‚·ãƒ”å®šç¾© // name, points, ingredients: Record<ææ–™å, å¿…è¦å€‹æ•°> const RECIPES = [ // 1ç‚¹ { name: "ãŠã«ãã‚Š", points: 1, ing: { "ã”é£¯": 1, "ã®ã‚Š": 1 } }, { name: "åµã‹ã‘ã”é£¯", points: 1, ing: { "ã”é£¯": 1, "åµ": 1 } }, { name: "è±šãƒãƒ©å¤§æ ¹", points: 1, ing: { "è±šè‚‰": 1, "å¤§æ ¹": 1 } }, { name: "ãƒ–ãƒªå¤§æ ¹", points: 1, ing: { "é­šè‚‰": 1, "å¤§æ ¹": 1 } }, { name: "ãƒ­ãƒ¼ãƒ«ã‚­ãƒ£ãƒ™ãƒ„", points: 1, ing: { "è±šè‚‰": 1, "ã‚­ãƒ£ãƒ™ãƒ„": 1 } }, { name: "ãƒãƒŠãƒŠã‚¸ãƒ¥ãƒ¼ã‚¹", points: 1, ing: { "ãƒãƒŠãƒŠ": 1, "ç‰›ä¹³": 1 } }, // 2ç‚¹ { name: "é®­ãŠã«ãã‚Š", points: 2, ing: { "ã”é£¯": 1, "ã®ã‚Š": 1, "é­šè‚‰": 1 } }, { name: "é‡èœç‚’ã‚", points: 2, ing: { "ã‚­ãƒ£ãƒ™ãƒ„": 1, "ã«ã‚“ã˜ã‚“": 1, "ç‰ã­ã": 1 } }, { name: "ãƒãƒ£ãƒ¼ãƒãƒ³", points: 2, ing: { "ã”é£¯": 1, "ç‰ã­ã": 1, "åµ": 1 } }, // 4ç‚¹ { name: "è±ªè¯ãªãƒãƒ£ãƒ¼ãƒãƒ³", points: 4, ing: { "ã”é£¯": 1, "ç‰ã­ã": 1, "åµ": 1, "è±šè‚‰": 1 } }, { name: "ã‚­ãƒ¼ãƒã‚«ãƒ¬ãƒ¼", points: 4, ing: { "ã”é£¯": 1, "ç‰ã­ã": 1, "ã‚«ãƒ¬ãƒ¼ç²‰": 1, "ç‰›è‚‰": 1 } }, { name: "ã‚ªãƒ ãƒ©ã‚¤ã‚¹", points: 4, ing: { "ã”é£¯": 1, "ç‰ã­ã": 1, "åµ": 1, "é¶è‚‰": 1 } }, { name: "ãƒãƒ³ãƒãƒ¼ã‚°", points: 4, ing: { "ç‰›è‚‰": 1, "è±šè‚‰": 1, "ç‰ã­ã": 1, "ç‰›ä¹³": 1 } }, { name: "è‚‰ã˜ã‚ƒãŒ", points: 4, ing: { "ç‰›è‚‰": 1, "ã˜ã‚ƒãŒã„ã‚‚": 1, "ç‰ã­ã": 1, "ã«ã‚“ã˜ã‚“": 1 } }, // 7ç‚¹ { name: "ã‚¯ãƒªãƒ¼ãƒ ã‚·ãƒãƒ¥ãƒ¼", points: 7, ing: { "ç‰›ä¹³": 1, "ç‰›è‚‰": 1, "ç‰ã­ã": 1, "ã«ã‚“ã˜ã‚“": 1, "ã˜ã‚ƒãŒã„ã‚‚": 1 } }, { name: "ã‚«ãƒ¬ãƒ¼", points: 7, ing: { "ç‰›è‚‰": 1, "ç‰ã­ã": 1, "ã«ã‚“ã˜ã‚“": 1, "ã˜ã‚ƒãŒã„ã‚‚": 1, "ã‚«ãƒ¬ãƒ¼ç²‰": 1 } }, // 10ç‚¹ { name: "æº€è…¹ã‚«ãƒ¬ãƒ¼", points: 10, ing: { "ã”é£¯": 1, "ç‰›è‚‰": 1, "ç‰ã­ã": 1, "ã«ã‚“ã˜ã‚“": 1, "ã˜ã‚ƒãŒã„ã‚‚": 1, "ã‚«ãƒ¬ãƒ¼ç²‰": 1 } }, { name: "çˆ†å¼¾ãŠã«ãã‚Š", points: 10, ing: { "ã”é£¯": 4, "ã®ã‚Š": 1, "é­šè‚‰": 1 } }, ];

// è‚‰ã®ç¨®é¡ï¼ˆç‰¹æ®Šå‹åˆ©ç”¨ï¼‰ const MEAT_TYPES = ["é¶è‚‰", "è±šè‚‰", "ç‰›è‚‰", "é­šè‚‰"] as const;

// -------------- å‹ --------------- let nextId = 1; const newId = () => ${nextId++};

type Card = { id: string; type: "material" | "event"; name: string; };

type ToolState = { åŒ…ä¸: boolean; å†·å‡åº«: boolean; ã¾ãªæ¿: boolean; };

type Player = { name: string; isCPU: boolean; hand: Card[]; setZone: Card[]; // è£å‘ãæƒ³å®šã ãŒUIã§ã¯å…¬é–‹ï¼ˆãƒ—ãƒ­ãƒˆç‰ˆï¼‰ score: number; tools: ToolState; meatsDone: Set<string>; // ä½œæˆæ¸ˆã¿æ–™ç†ã«å«ã¾ã‚ŒãŸè‚‰ç¨®é¡ usedEventThisTurn: boolean; usedSpecial3ptThisTurn: boolean; // å‰µä½œæ–™ç†/ç·Šæ€¥èª¿ç†ã‚’ä½¿ã£ãŸã‚‰true rolesMadeThisTurn: number; // åŒä¸€ã‚¿ãƒ¼ãƒ³ã®å½¹é”æˆæ•° };

type Supply = { tools: Record<(typeof TOOLS)[number], number>; // æ®‹æ•° };

type Settings = { endDiscardThreshold: 4 | 3; // 4æšä»¥ä¸Šãªã‚‰2æšæ®‹ã— / 3æšä»¥ä¸Šãªã‚‰2æšæ®‹ã— eventDraw30Pct: boolean; // ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºæ™‚ã€30%ã§ã‚¤ãƒ™ãƒ³ãƒˆ1æšè¿½åŠ  };

type Phase = "draw" | "main" | "end";

// -------------- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ --------------- function shuffle<T>(arr: T[]): T[] { const a = [...arr]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }

function createDeck(): Card[] { const deck: Card[] = []; Object.entries(MATERIAL_COUNTS).forEach(([name, count]) => { for (let i = 0; i < count; i++) deck.push({ id: newId(), type: "material", name }); }); Object.entries(EVENT_COUNTS).forEach(([name, count]) => { for (let i = 0; i < count; i++) deck.push({ id: newId(), type: "event", name }); }); return shuffle(deck); }

function initialSupply(): Supply { return { tools: { ...TOOL_COUNTS } }; }

function emptyTools(): ToolState { return { åŒ…ä¸: false, å†·å‡åº«: false, ã¾ãªæ¿: false }; }

function countByName(cards: Card[]): Record<string, number> { const m: Record<string, number> = {}; for (const c of cards) m[c.name] = (m[c.name] || 0) + 1; return m; }

function canSatisfyRecipe( available: Record<string, number>, ing: Record<string, number>, hasKnife: boolean ): boolean { // é€šå¸¸ãƒã‚§ãƒƒã‚¯ let lacks = 0; let missingMap: Record<string, number> = {}; for (const [name, need] of Object.entries(ing)) { const have = available[name] || 0; if (have < need) { missingMap[name] = need - have; lacks += need - have; } } if (lacks <= 0) return true; // åŒ…ä¸ï¼šä»»æ„ã®1ç¨®é¡ã®ææ–™ã‚’+1å€‹åˆ†ã¨ã—ã¦æ‰±ãˆã‚‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«è¿‘ä¼¼ï¼‰ if (hasKnife) { // åŒ…ä¸ã§è£œãˆã‚‹ã®ã¯1æšåˆ†ã ã‘ // æ¬ ã‘ã¦ã„ã‚‹ç·æ•°ãŒ1ä»¥ä¸‹ã€ã‹ã¤æ¬ ã‘ã¦ã„ã‚‹ææ–™ã®ã†ã¡ã€ // ã‚‚ã¨ã‚‚ã¨1æšä»¥ä¸ŠæŒã£ã¦ã„ã‚‹ææ–™åãŒå­˜åœ¨ã™ã‚‹ï¼ˆ=ãã®ã‚«ãƒ¼ãƒ‰ã‚’2æšæ‰±ã„ã§ãã‚‹ï¼‰ if (lacks <= 1) { // æ—¢ã«1æšä»¥ä¸ŠæŒã£ã¦ã„ã‚‹ææ–™ãŒã‚ã‚‹ï¼Ÿ const canDouble = Object.keys(ing).some((name) => (available[name] || 0) >= 1); if (canDouble) return true; } } return false; }

function pickCardsForRecipe( pool: Card[], ing: Record<string, number>, hasKnife: boolean ): Card[] | null { // ã‚°ãƒªãƒ¼ãƒ‡ã‚£ã§ææ–™ã‚’é¸ã¶ const picked: Card[] = []; const need = { ...ing } as Record<string, number>; for (const name of Object.keys(need)) { for (const c of pool) { if (c.type === "material" && c.name === name && need[name] > 0) { picked.push(c); need[name] -= 1; if (need[name] === 0) break; } } } // ä¸è¶³åˆ†ã‚’åŒ…ä¸ã§è£œãˆã‚‹ã‹åˆ¤å®šï¼ˆä¸è¶³1ãªã‚‰OKã¨ã™ã‚‹ï¼‰ const lacks = Object.values(need).reduce((a, b) => a + Math.max(0, b), 0); if (lacks === 0) return picked; if (hasKnife && lacks === 1) { // æ—¢ã«æŒã£ã¦ã„ã‚‹ææ–™ã®ã„ãšã‚Œã‹ã‚’2æšæ‰±ã„ã§ãã‚‹ã¨ã¿ãªã™ â†’ pickedã¯ãã®ã¾ã¾ const haveAny = Object.keys(ing).some((name) => pool.some((c) => c.type === "material" && c.name === name)); if (haveAny) return picked; } return null; }

function top<T>(arr: T[]): T | undefined { return arr[arr.length - 1]; }

// -------------- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ --------------- export default function App() { const [deck, setDeck] = useState<Card[]>(() => createDeck()); const [discard, setDiscard] = useState<Card[]>([]); const [supply, setSupply] = useState<Supply>(() => initialSupply()); const [settings, setSettings] = useState<Settings>({ endDiscardThreshold: 4, eventDraw30Pct: false });

const [players, setPlayers] = useState<Player[]>(() => [ { name: "ã‚ãªãŸ", isCPU: false, hand: [], setZone: [], score: 0, tools: emptyTools(), meatsDone: new Set<string>(), usedEventThisTurn: false, usedSpecial3ptThisTurn: false, rolesMadeThisTurn: 0, }, { name: "CPU", isCPU: true, hand: [], setZone: [], score: 0, tools: emptyTools(), meatsDone: new Set<string>(), usedEventThisTurn: false, usedSpecial3ptThisTurn: false, rolesMadeThisTurn: 0, }, ]);

const [current, setCurrent] = useState(0); // ç¾åœ¨æ‰‹ç•ª const [phase, setPhase] = useState<Phase>("draw"); const [log, setLog] = useState<string[]>([]); const [reveal, setReveal] = useState<Card[]>([]); // é£Ÿææ¢ç´¢ãªã©ã§ã‚ãã£ãŸã‚«ãƒ¼ãƒ‰ const currentPlayer = players[current]; const opponentIndex = (current + 1) % players.length; const opponent = players[opponentIndex];

// åˆæœŸé…å¸ƒ useEffect(() => { if (players[0].hand.length === 0 && players[1].hand.length === 0) { dealInitial(); } // eslint-disable-next-line react-hooks/exhaustive-deps }, []);

function logPush(s: string) { setLog((L) => [...L, s]); }

function draw(n: number): Card[] { let d = [...deck]; let disc = [...discard];

const drawn: Card[] = [];
for (let i = 0; i < n; i++) {
  if (d.length === 0) {
    if (disc.length === 0) break; // ä½•ã‚‚å¼•ã‘ãªã„
    // ãƒªã‚·ãƒ£ãƒƒãƒ•ãƒ«
    d = shuffle(disc);
    disc = [];
    logPush("å±±æœ­ãŒåˆ‡ã‚ŒãŸã®ã§ã€ã‚´ãƒŸç®±ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦å±±æœ­ã«æˆ»ã—ãŸï¼");
  }
  drawn.push(d.pop()!);
}
setDeck(d);
setDiscard(disc);
return drawn;

}

function dealInitial() { // å±±æœ­ã‚’ä½œã‚Šç›´ã—ã¦é…ã‚Šç›´ã— const fresh = createDeck(); setDeck(fresh); setDiscard([]); setSupply(initialSupply());

setPlayers((ps) => {
  const P = structuredClone(ps) as Player[];
  for (let p of P) {
    p.hand = [];
    p.setZone = [];
    p.score = 0;
    p.tools = emptyTools();
    p.meatsDone = new Set<string>();
    p.usedEventThisTurn = false;
    p.usedSpecial3ptThisTurn = false;
    p.rolesMadeThisTurn = 0;
  }
  // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼4æšã«ãªã‚‹ã¾ã§å¼•ã
  setTimeout(() => {
    for (let idx = 0; idx < P.length; idx++) {
      const need = 4 - P[idx].hand.length;
      if (need > 0) {
        const got = draw(need);
        P[idx].hand.push(...got);
      }
    }
    setPlayers([...P]);
    setCurrent(0);
    setPhase("draw");
    setLog([]);
    logPush("ã‚²ãƒ¼ãƒ é–‹å§‹ï¼å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ‰‹æœ­ãŒ4æšã«ãªã‚‹ã¾ã§ãƒ‰ãƒ­ãƒ¼ã€‚");
  }, 0);
  return P;
});

}

// ---------- ã‚¿ãƒ¼ãƒ³é€²è¡Œ ---------- useEffect(() => { if (phase === "draw" && currentPlayer) { doDrawPhase(current); } // eslint-disable-next-line react-hooks/exhaustive-deps }, [phase, current]);

function doDrawPhase(pIndex: number) { setPlayers((ps) => { const P = structuredClone(ps) as Player[]; const p = P[pIndex]; // ã¾ãªæ¿ï¼šæ‰‹æœ­ãŒ5æšã«ãªã‚‹ã¾ã§ã€ãã‚Œä»¥å¤–ã¯4æšã¾ã§ const limit = p.tools["ã¾ãªæ¿"] ? 5 : 4; const need = Math.max(0, limit - p.hand.length); if (need > 0) { const got = draw(need); p.hand.push(...got); if (need > 0) logPush(${p.name}ã¯${need}æšãƒ‰ãƒ­ãƒ¼ã€‚); } // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼š30%ã§ã‚¤ãƒ™ãƒ³ãƒˆ1æšè¿½åŠ  if (settings.eventDraw30Pct) { if (Math.random() < 0.3) { const got = draw(1); if (got[0]) { p.hand.push(got[0]); logPush(${p.name}ã¯ãƒœãƒ¼ãƒŠã‚¹ã§1æšãƒ‰ãƒ­ãƒ¼ï¼ï¼ˆ30%ãƒ«ãƒ¼ãƒ«ï¼‰); } } } // ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã®ãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ p.usedEventThisTurn = false; p.usedSpecial3ptThisTurn = false; p.rolesMadeThisTurn = 0; return P; }); setPhase("main"); }

function endTurn() { const threshold = settings.endDiscardThreshold; // 4 or 3 const keepCount = 2; setPlayers((ps) => { const P = structuredClone(ps) as Player[]; const p = P[current]; if (p.hand.length >= threshold) { // ã‚·ãƒ³ãƒ—ãƒ«ï¼šæ‰‹æœ­ã‚’è‡ªå‹•è©•ä¾¡ã—ã¦2æšæ®‹ã™ï¼ˆUIã§é¸æŠã™ã‚‹ä»£æ›¿ï¼‰ const best = pickBestKeeps(p.hand, keepCount); const toDiscard = p.hand.filter((c) => !best.includes(c)); p.hand = best; setDiscard((D) => [...D, ...toDiscard]); if (toDiscard.length > 0) logPush(${p.name}ã¯æ‰‹æœ­ã‚’${toDiscard.length}æšæ¨ã¦ã¦2æšã ã‘æ®‹ã—ãŸã€‚); } return P; }); // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ const next = (current + 1) % players.length; setCurrent(next); setPhase("draw"); }

function pickBestKeeps(hand: Card[], k: number): Card[] { // è¶…ç°¡æ˜“ï¼šææ–™ã‚«ãƒ¼ãƒ‰å„ªå…ˆâ†’ã‚¤ãƒ™ãƒ³ãƒˆã¯æ±ç”¨æ€§é«˜ã„ã‚‚ã®ï¼ˆçˆ†è²·ã„/é£Ÿææ¢ç´¢ï¼‰ const scoreCard = (c: Card): number => { if (c.type === "material") { // éœ€è¦ã®é«˜ã„ææ–™ã«ã‚¹ã‚³ã‚¢ä»˜ä¸ const weight: Record<string, number> = { "ã”é£¯": 4, "ç‰ã­ã": 3, "åµ": 3, "ç‰›è‚‰": 3, "è±šè‚‰": 3, "é¶è‚‰": 3, "ã«ã‚“ã˜ã‚“": 2, "ã˜ã‚ƒãŒã„ã‚‚": 2, "ç‰›ä¹³": 2, "ã®ã‚Š": 2, "é­šè‚‰": 2, "ã‚«ãƒ¬ãƒ¼ç²‰": 2, "ã‚­ãƒ£ãƒ™ãƒ„": 1, "å¤§æ ¹": 1, "ãƒãƒŠãƒŠ": 1, }; return 10 + (weight[c.name] || 1); } else { const w: Record<string, number> = { "çˆ†è²·ã„": 7, "é£Ÿææ¢ç´¢": 6, "ã‚´ãƒŸåé›†è»Š": 5, "ã‚„ã‚Šç›´ã—": 5, "ç·Šæ€¥èª¿ç†": 4, "ç‰©ã€…äº¤æ›": 4, "å¤§æƒé™¤": 3, "ã‚„ã£ã±ã‚„ãƒ¼ã‚ãŸã£ï¼": 2, "å‰µä½œæ–™ç†": 2 }; return 5 + (w[c.name] || 0); } }; return [...hand].sort((a, b) => scoreCard(b) - scoreCard(a)).slice(0, k); }

// ---------- å½¹ä½œæˆ ---------- function tryMakeRecipe(pIndex: number, recipeName: string) { setPlayers((ps) => { const P = structuredClone(ps) as Player[]; const me = P[pIndex]; const recipe = RECIPES.find((r) => r.name === recipeName); if (!recipe) return P; if (me.usedSpecial3ptThisTurn) { logPush(${me.name}ã¯ã“ã®ã‚¿ãƒ¼ãƒ³ã€ä»–ã®å½¹ã‚’ä½œã‚Œãªã„ã€‚); return P; } // ä½¿ç”¨å¯èƒ½ã‚«ãƒ¼ãƒ‰ = æ‰‹æœ­+ã‚»ãƒƒãƒˆ const pool = [...me.hand, ...me.setZone]; const counts = countByName(pool); if (!canSatisfyRecipe(counts, recipe.ing, me.tools["åŒ…ä¸"])) { logPush(${me.name}ã¯ã€Œ${recipe.name}ã€ã‚’ä½œã‚‹ææ–™ãŒè¶³ã‚Šãªã„ã€‚); return P; } const used = pickCardsForRecipe(pool, recipe.ing, me.tools["åŒ…ä¸"]); if (!used) { logPush(${me.name}ã¯ã€Œ${recipe.name}ã€ã®ææ–™é¸å®šã«å¤±æ•—ã€‚); return P; } // ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’æ‰‹æœ­/ã‚»ãƒƒãƒˆã‹ã‚‰å–ã‚Šé™¤ãã€ã‚´ãƒŸç®±ã¸ const usedIds = new Set(used.map((c) => c.id)); me.hand = me.hand.filter((c) => !usedIds.has(c.id)); me.setZone = me.setZone.filter((c) => !usedIds.has(c.id)); setDiscard((D) => [...D, ...used]); me.score += recipe.points; me.rolesMadeThisTurn += 1; // è‚‰ç¨®é¡ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚° for (const meat of MEAT_TYPES) { if (recipe.ing[meat]) me.meatsDone.add(meat); } logPush(${me.name}ã¯ã€Œ${recipe.name}ã€ã‚’å®Œæˆï¼ +${recipe.points}ç‚¹ï¼ˆåˆè¨ˆ${me.score}ç‚¹ï¼‰); // å‹åˆ©åˆ¤å®š if (me.score >= 10) { logPush(â˜… ${me.name}ã¯10ç‚¹åˆ°é”ï¼å‹åˆ©ï¼); } if (MEAT_TYPES.every((m) => me.meatsDone.has(m)) && me.score >= 7) { logPush(â˜… ${me.name}ã¯ç‰¹æ®Šå‹åˆ©ã€Œæ–™ç†ã®é‰„äººã€ã‚’é”æˆï¼å‹åˆ©ï¼); } if (me.rolesMadeThisTurn >= 3) { logPush(â˜… ${me.name}ã¯ç‰¹æ®Šå‹åˆ©ã€Œæº€è…¹ã®é”äººã€ã‚’é”æˆï¼å‹åˆ©ï¼); } return P; }); }

// ---------- ã‚»ãƒƒãƒˆ/è³¼å…¥ ---------- function setMaterialFromHand(pIndex: number, cardId: string) { setPlayers((ps) => { const P = structuredClone(ps) as Player[]; const me = P[pIndex]; const cap = me.tools["å†·å‡åº«"] ? 3 : 2; if (me.setZone.length >= cap) { logPush(${me.name}ã¯ã“ã‚Œä»¥ä¸Šã‚»ãƒƒãƒˆã§ããªã„ï¼ˆä¸Šé™${cap}æšï¼‰ã€‚); return P; } const idx = me.hand.findIndex((c) => c.id === cardId && c.type === "material"); if (idx < 0) return P; const [card] = me.hand.splice(idx, 1); me.setZone.push(card); logPush(${me.name}ã¯ææ–™ã€Œ${card.name}ã€ã‚’ã‚»ãƒƒãƒˆã€‚); return P; }); }

function buyTool(pIndex: number, tool: (typeof TOOLS)[number]) { setPlayers((ps) => { const P = structuredClone(ps) as Player[]; const me = P[pIndex]; if (me.score < 3) { logPush(${me.name}ã¯ç‚¹æ•°ãŒè¶³ã‚Šãªã„ï¼ˆ3ç‚¹å¿…è¦ï¼‰ã€‚); return P; } if (me.tools[tool]) { logPush(${me.name}ã¯æ—¢ã«ã€Œ${tool}ã€ã‚’æŒã£ã¦ã„ã‚‹ã€‚); return P; } setSupply((S) => { if (S.tools[tool] <= 0) { logPush(ã‚µãƒ—ãƒ©ã‚¤ã«ã€Œ${tool}ã€ãŒæ®‹ã£ã¦ã„ãªã„ã€‚); return S; } const NS = structuredClone(S) as Supply; NS.tools[tool] -= 1; me.tools[tool] = true; me.score -= 3; logPush(${me.name}ã¯ã€Œ${tool}ã€ã‚’3ç‚¹ã§è³¼å…¥ï¼ˆæ®‹${NS.tools[tool]}ï¼‰ã€‚); return NS; }); return P; }); }

// ---------- ã‚¤ãƒ™ãƒ³ãƒˆ ---------- function useEvent(pIndex: number, cardId: string) { setPlayers((ps) => { const P = structuredClone(ps) as Player[]; const me = P[pIndex]; if (me.usedEventThisTurn) { logPush(${me.name}ã¯æ—¢ã«ä»Šã‚¿ãƒ¼ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚); return P; } const idx = me.hand.findIndex((c) => c.id === cardId && c.type === "event"); if (idx < 0) return P; const [ev] = me.hand.splice(idx, 1); setDiscard((D) => [...D, ev]); me.usedEventThisTurn = true;

switch (ev.name) {
    case "çˆ†è²·ã„": {
      const got = draw(3);
      me.hand.push(...got);
      logPush(`${me.name}ã¯ã€Œçˆ†è²·ã„ã€ã§3æšãƒ‰ãƒ­ãƒ¼ã€‚`);
      break;
    }
    case "ã‚„ã‚Šç›´ã—": {
      const cnt = me.hand.length;
      setDiscard((D) => [...D, ...me.hand]);
      me.hand = [];
      const got = draw(cnt);
      me.hand.push(...got);
      logPush(`${me.name}ã¯ã€Œã‚„ã‚Šç›´ã—ã€ã§æ‰‹æœ­ã‚’ç·å…¥æ›¿ã€‚`);
      break;
    }
    case "ã‚´ãƒŸåé›†è»Š": {
      // ã‚´ãƒŸç®±ã‹ã‚‰ææ–™1æšã‚’é¸ã‚“ã§å›åï¼ˆãƒ—ãƒ­ãƒˆï¼šç›´è¿‘ã‹ã‚‰å„ªå…ˆï¼‰
      const matIndex = [...discard].reverse().findIndex((c) => c.type === "material");
      if (matIndex >= 0) {
        const realIdx = discard.length - 1 - matIndex;
        const card = discard[realIdx];
        setDiscard((D) => D.filter((_, i) => i !== realIdx));
        me.hand.push(card);
        logPush(`${me.name}ã¯ã€Œã‚´ãƒŸåé›†è»Šã€ã§ã€Œ${card.name}ã€ã‚’å›åã€‚`);
      } else {
        logPush(`${me.name}ã¯ã€Œã‚´ãƒŸåé›†è»Šã€ã‚’ä½¿ã£ãŸãŒã€å›åã§ãã‚‹ææ–™ãŒãªã„ã€‚`);
      }
      break;
    }
    case "é£Ÿææ¢ç´¢": {
      const got = draw(3);
      setReveal(got);
      // ãƒ—ãƒ­ãƒˆï¼šè‡ªå‹•ã§ææ–™æœ€å¤§2æšã‚’æ‰‹æœ­ã¸ã€æ®‹ã‚Šã¯æ¨ã¦æœ­
      const mats = got.filter((c) => c.type === "material").slice(0, 2);
      const rest = got.filter((c) => !mats.includes(c));
      me.hand.push(...mats);
      setDiscard((D) => [...D, ...rest]);
      logPush(`${me.name}ã¯ã€Œé£Ÿææ¢ç´¢ã€ã§3æšã‚ãã‚Šã€ææ–™${mats.length}æšã‚’ç²å¾—ã€‚`);
      break;
    }
    case "ç‰©ã€…äº¤æ›": {
      // ãƒ—ãƒ­ãƒˆï¼šCPUç›¸æ‰‹ãªã‚‰è‡ªå‹•ã€å¯¾äººãªã‚‰ç°¡æ˜“UIï¼ˆã“ã“ã§ã¯è‡ªå‹•ï¼‰
      const opp = pIndex === 0 ? players[1] : players[0];
      const oppMat = opp.hand.find((c) => c.type === "material");
      const myMat = me.hand.find((c) => c.type === "material");
      if (oppMat && myMat) {
        opp.hand = opp.hand.filter((c) => c.id !== oppMat.id);
        me.hand = me.hand.filter((c) => c.id !== myMat.id);
        opp.hand.push(myMat);
        me.hand.push(oppMat);
        logPush(`${me.name}ã¯ã€Œç‰©ã€…äº¤æ›ã€ã§${opp.name}ã¨ææ–™ã‚’1æšäº¤æ›ã€‚`);
      } else {
        logPush(`${me.name}ã¯ã€Œç‰©ã€…äº¤æ›ã€ã‚’ä½¿ã£ãŸãŒæ¡ä»¶ä¸æˆç«‹ã€‚`);
      }
      break;
    }
    case "ã‚„ã£ã±ã‚„ãƒ¼ã‚ãŸã£ï¼": {
      const cnt = me.setZone.length;
      if (cnt > 0) {
        me.hand.push(...me.setZone);
        me.setZone = [];
        logPush(`${me.name}ã¯ã€Œã‚„ã£ã±ã‚„ãƒ¼ã‚ãŸã£ï¼ã€ã§ã‚»ãƒƒãƒˆã‚’æ‰‹æœ­ã«æˆ»ã—ãŸï¼ˆ${cnt}æšï¼‰ã€‚`);
      } else {
        logPush(`${me.name}ã¯ã€Œã‚„ã£ã±ã‚„ãƒ¼ã‚ãŸã£ï¼ã€ã‚’ä½¿ã£ãŸãŒã€ã‚»ãƒƒãƒˆãŒãªã„ã€‚`);
      }
      break;
    }
    case "å¤§æƒé™¤": {
      const oppIndex = pIndex === 0 ? 1 : 0;
      const opp = P[oppIndex];
      const cnt = opp.hand.length;
      setDiscard((D) => [...D, ...opp.hand]);
      opp.hand = [];
      const got = draw(cnt);
      opp.hand.push(...got);
      logPush(`${me.name}ã¯ã€Œå¤§æƒé™¤ã€ã§${opp.name}ã®æ‰‹æœ­ã‚’ãƒªã‚»ãƒƒãƒˆã€‚`);
      break;
    }
    case "å‰µä½œæ–™ç†": {
      // æ‰‹æœ­ã®ææ–™2æšã‚’æ¨ã¦ã¦3ç‚¹å¾—ã‚‹ï¼ˆã“ã®ã‚¿ãƒ¼ãƒ³ä»–ã®å½¹ä¸å¯ï¼‰
      const mats = me.hand.filter((c) => c.type === "material").slice(0, 2);
      if (mats.length < 2) {
        logPush(`${me.name}ã¯ã€Œå‰µä½œæ–™ç†ã€ã‚’ä½¿ãˆãªã‹ã£ãŸï¼ˆææ–™ãŒè¶³ã‚Šãªã„ï¼‰ã€‚`);
      } else {
        const ids = new Set(mats.map((c) => c.id));
        me.hand = me.hand.filter((c) => !ids.has(c.id));
        setDiscard((D) => [...D, ...mats]);
        me.score += 3;
        me.usedSpecial3ptThisTurn = true;
        me.rolesMadeThisTurn += 1; // ã“ã‚Œã¯ã€Œå½¹æ‰±ã„ã€ã®3ç‚¹
        logPush(`${me.name}ã¯ã€Œå‰µä½œæ–™ç†ã€ã‚’ç™ºå‹•ï¼ +3ç‚¹ï¼ˆåˆè¨ˆ${me.score}ç‚¹ï¼‰ã€‚ä»Šã‚¿ãƒ¼ãƒ³ä»–ã®å½¹ã¯ä½œã‚Œãªã„ã€‚`);
      }
      break;
    }
    case "ç·Šæ€¥èª¿ç†": {
      if (me.score <= 5) {
        const mat = me.hand.find((c) => c.type === "material");
        if (mat) {
          me.hand = me.hand.filter((c) => c.id !== mat.id);
          setDiscard((D) => [...D, mat]);
          me.score += 3;
          me.usedSpecial3ptThisTurn = true;
          me.rolesMadeThisTurn += 1;
          logPush(`${me.name}ã¯ã€Œç·Šæ€¥èª¿ç†ã€ã§+3ç‚¹ï¼ˆåˆè¨ˆ${me.score}ç‚¹ï¼‰ã€‚ä»Šã‚¿ãƒ¼ãƒ³ä»–ã®å½¹ã¯ä½œã‚Œãªã„ã€‚`);
        } else {
          logPush(`${me.name}ã¯ã€Œç·Šæ€¥èª¿ç†ã€ã‚’ä½¿ãˆãªã‹ã£ãŸï¼ˆææ–™ãŒãªã„ï¼‰ã€‚`);
        }
      } else {
        logPush(`${me.name}ã¯ã€Œç·Šæ€¥èª¿ç†ã€ã‚’ä½¿ãˆãªã„ï¼ˆå¾—ç‚¹ãŒ5ç‚¹ä»¥ä¸‹ã§ãªã„ï¼‰ã€‚`);
      }
      break;
    }
  }
  return P;
});

}

// ---------- CPU AI ---------- useEffect(() => { if (phase === "main" && currentPlayer?.isCPU) { const t = setTimeout(cpuTurn, 700); return () => clearTimeout(t); } // eslint-disable-next-line react-hooks/exhaustive-deps }, [phase, current, players, deck, discard]);

function cpuTurn() { // 1) ä½œã‚Œã‚‹æœ€å¤§ãƒã‚¤ãƒ³ãƒˆã®å½¹ã‚’æ¢ã—ã¦ä½œã‚‹ const me = players[current]; const pool = [...me.hand, ...me.setZone]; const counts = countByName(pool); const canList = RECIPES.filter((r) => canSatisfyRecipe(counts, r.ing, me.tools["åŒ…ä¸"])) .sort((a, b) => b.points - a.points); if (!me.usedSpecial3ptThisTurn && canList[0]) { tryMakeRecipe(current, canList[0].name); return; // ã‚‚ã†ä¸€åº¦ãƒ¡ã‚¤ãƒ³ç¶™ç¶šï¼ˆåŒã‚¿ãƒ¼ãƒ³è¤‡æ•°ä½œæˆå¯èƒ½ï¼‰ }

// 2) ã‚¤ãƒ™ãƒ³ãƒˆã‚’1æšæ´»ç”¨ï¼ˆçˆ†è²·ã„/é£Ÿææ¢ç´¢/ã‚„ã‚Šç›´ã—å„ªå…ˆï¼‰
if (!me.usedEventThisTurn) {
  const evPriority = ["çˆ†è²·ã„", "é£Ÿææ¢ç´¢", "ã‚„ã‚Šç›´ã—", "ã‚´ãƒŸåé›†è»Š", "ç·Šæ€¥èª¿ç†", "ã‚„ã£ã±ã‚„ãƒ¼ã‚ãŸã£ï¼", "ç‰©ã€…äº¤æ›", "å¤§æƒé™¤", "å‰µä½œæ–™ç†"];
  const ev = me.hand.find((c) => c.type === "event" && evPriority.includes(c.name));
  if (ev) { useEvent(current, ev.id); return; }
}

// 3) ã‚»ãƒƒãƒˆæ ã«ææ–™ã‚’å…¥ã‚Œã¦å°†æ¥ã«ç¹‹ã
const cap = me.tools["å†·å‡åº«"] ? 3 : 2;
if (me.setZone.length < cap) {
  // é‡ç”¨åº¦ã®é«˜ã„ææ–™ã‹ã‚‰
  const pri = ["ã”é£¯", "ç‰ã­ã", "åµ", "ç‰›è‚‰", "è±šè‚‰", "é¶è‚‰", "ã«ã‚“ã˜ã‚“", "ã˜ã‚ƒãŒã„ã‚‚", "ç‰›ä¹³", "é­šè‚‰", "ã®ã‚Š", "ã‚«ãƒ¬ãƒ¼ç²‰", "ã‚­ãƒ£ãƒ™ãƒ„", "å¤§æ ¹", "ãƒãƒŠãƒŠ"];
  const mat = me.hand.find((c) => c.type === "material" && pri.includes(c.name));
  if (mat) { setMaterialFromHand(current, mat.id); return; }
}

// 4) ãƒ„ãƒ¼ãƒ«è³¼å…¥ï¼ˆç‚¹ãŒä½™ã£ã¦ãŸã‚‰ ã¾ãªæ¿â†’åŒ…ä¸â†’å†·å‡åº«ï¼‰
const order: (typeof TOOLS)[number][] = ["ã¾ãªæ¿", "åŒ…ä¸", "å†·å‡åº«"];
for (const t of order) {
  if (!me.tools[t] && me.score >= 3 && supply.tools[t] > 0) { buyTool(current, t); return; }
}

// 5) ã‚¨ãƒ³ãƒ‰
endTurn();

}

// ---------- UIè£œåŠ© ---------- const yourTurn = current === 0; const gameEnded = useMemo(() => { const winners: string[] = []; players.forEach((p) => { if (p.score >= 10) winners.push(p.name); if (MEAT_TYPES.every((m) => p.meatsDone.has(m)) && p.score >= 7) winners.push(p.name); if (p.rolesMadeThisTurn >= 3) winners.push(p.name); }); return winners.length > 0 ? winners : null; }, [players]);

// ---------- ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ---------- return ( <div className="w-full min-h-screen bg-gradient-to-b from-orange-50 to-orange-100 text-slate-800 p-4"> <div className="max-w-6xl mx-auto"> <header className="flex items-center justify-between mb-4"> <h1 className="text-2xl md:text-3xl font-bold">Battle Ã  la carte â€“ ãƒ–ãƒ©ã‚¦ã‚¶ç‰ˆï¼ˆCPUã¤ãï¼‰</h1> <div className="flex items-center gap-2"> <button className="px-3 py-1 rounded-xl bg-white shadow hover:shadow-md" onClick={dealInitial}>ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button> <details className="px-3 py-1 rounded-xl bg-white shadow"> <summary className="cursor-pointer">è¨­å®š</summary> <div className="py-2 flex flex-col gap-2"> <label className="flex items-center gap-2"> <input type="checkbox" checked={settings.eventDraw30Pct} onChange={(e) => setSettings((s) => ({